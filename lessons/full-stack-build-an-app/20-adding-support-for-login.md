---
title: Adding Support For the Login Feature
order: 20
---

# Adding Support For the Login Feature

For our users to login, we need to present the user with a form where they can
provide their username and password. This data then needs to be processed by the
backend to validate the information is correct and then inform the client of the
success or failure.

We also need some way for the client to tell the server with every API request
it subsequently makes that the user is logged in and who they are. It would not
be a good idea to _store_ the user's password and include that with every
request. We want to handle the user's unencrypted password as little as
possible. To do this the client and the server communicate with a system known
as JavaScript Web Tokens or JWTs. (some pronounce this as Jay-Double-U-Tees and
others as `joots` to rhyme with `scoots`)

The idea of a JWT is an encoded and cryptographically **signed** bit of data
that the server can hand back to the client which means "If you hand me back
this data exactly, I'll recognize you as the user it specifies"). To do this the
server needs a way to format, "sign", and then encode the response.

JWTs can store any information we wish, though we should keep them small since
it does add overhead to each API request they are included with. Typically we
store some details from the user to include, but not be limited to, their user
id. We may also store their names and email.

## What does a JWT look like?

This is an example of a JWT:

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJZCI6IjEiLCJGdWxsTmFtZSI6IkdhdmluIFN0YXJrIiwiRW1haWwiOiJnYXZpbkBnc3RhcmsuY29tIiwibmJmIjoxNTk0MjMyOTE5LCJleHAiOjE1OTQyNjg5MTksImlhdCI6MTU5NDIzMjkxOX0.k-xpH_Fu45BBUQWWTWHVxATAZk-X_Ae-_hXZFjF8LQE
```

Pretty indecipherable, right? Fortunately, there are easily decoded by our
computers. The website `jwt.io` has a decoder right on their home page. Try
copying the above text and pasting it into their _Debugger_

What you will see is this:

![jwt](./assets/jwt.png)

On the left side is our original JWT. However, you will notice that it has
become color-coded. Each of the colors of the text represents what part of the
JWT it represents.

There are three parts to a JWT:

- Header
- Payload
- Verification

The `Header` section tells the JWT system what kind of token this is, and what
_algorithm_ was used to encode the token. This comes first so the JWT system can
properly decode the rest of the token.

Next comes the `payload`. This is the part we, as developers, can specify data
within. Each of these elements, though decoded as JSON are called `claims`. The
first _three_ claims here, `Id`, `FullName`, and `Email` were generated by code
(which we about to write) and represent the details of a logged-in user. The
next three represent details about the token itself. Each of these is encoded as
numbers. `nbf` is a claim that stands for `Not Before`, meaning that the token
is not valid for any time _earlier_ than the given timestamp. The claim `exp`
which stats for `Expiration` and represents the time when this token is no
longer valid. Finally, `iat` is a claim that indicates when the token was
issued.

The final section is the _signature_ of the token. It uses cryptographic
functions to add data to the token using a server's _secret key_. This data
represents a _hash_ of the other parts of the token. If anyone were to change
even a single character of the other parts of the message, say changing the `Id`
from `1` to `2` they would **not** be able to resign that message with valid
data. They lack the server's secret key. In this way, the data can easily be
decoded by anyone, but cannot be changed/updated by anyone other than the server
itself. Thus it is important not to put **secret** information in the payload
since JWT tokens are not **encrypted**.

When a user logs in we will have our server generate a new JWT token and return
this to the client. The client can simply store this token and provide it back
to the server with any API request that needs to be done by an _authenticated_
user. We do this by specifying a special `header` value that includes this
token.

## Adding a controller to manage "sessions"

Thinking again about _resources_ we will consider the user logging in to be the
_CREATION_ of a _Session_. While we won't record the creation of a session in
our database, though we could, we still think of this as it's own resource with
a `POST` create action.

As such we will create a `Sessions` controller to store this `POST` action.

```csharp
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using TacoTuesday.Models;
using TacoTuesday.Utils;;

namespace TacoTuesday.Controllers
{
    // All of these routes will be at the base URL:     /api/Sessions
    // That is what "api/[controller]" means below. It uses the name of the controller
    // in this case RestaurantsController to determine the URL
    [Route("api/[controller]")]
    [ApiController]
    public class SessionsController : ControllerBase
    {
        // This is the variable you use to have access to your database
        private readonly DatabaseContext _context;

        readonly protected string JWT_KEY;

        // Constructor that receives a reference to your database context
        // and stores it in _context for you to use in your API methods
        public SessionsController(DatabaseContext context, IConfiguration config)
        {
            _context = context;
            JWT_KEY = config["JWT_KEY"];
        }
    }
}
```

You will notice a few things different than our traditional controller.

In addition to storing the `_context` with our `DatabaseContext`, we are also
storing a variable with a `JWT_KEY`. This is the secret key we will use to sign
the JWT tokens.

This token is passed to us when the controller is constructed, just as the
context is. It is available to us from a `config` variable that is supplied by
the framework.

From this `config` variable, we can ask for the `["JWK_KEY"]` and store that in
our variable.

This is another example of
[`Dependency Injection`](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1).
The use of
[`Dependency Injection`](https://en.wikipedia.org/wiki/Dependency_injection)
allows the framework to provide information to our code, like our controller,
without us having to know details of how that information is managed or
accessed. In this case, a configuration object is supplied. In development, this
will be managed in local configuration files. In production, it will be managed
by our hosting provider. In either case, we are not concerned with those
details. We only need to accept this `config` variable and extract the data we
need.

## Creating our JWT_KEY for development

When your project was created it asked you to create a user secret to use in
development.

To set up our development mode for storing this secret `JWT_KEY` you initialized
support for `user secrets` by running this command:

```shell
dotnet user-secrets init
```

This creates a file outside our project to store secret information. This way
the data is not stored in our repository for others to see.

Next, you told the secrets to store `JWT_KEY`

```shell
dotnet user-secrets set "JWT_KEY" "Long set of Random Letters and Numbers like iExEUNxxv9zylIuT2VMrsMsQEKjjKs1XrYFntsafKgQs90HndTX0yw8xLhFHk9O"
```

The `JWT_KEY` should be a relatively long set of random characters. This is
called _high entropy_ implying that it will be very hard for someone to guess
this secret. A good website to generate these kinds of secrets is:
[Gibson Research Corporation's Password Page](https://www.grc.com/passwords.htm)

> NOTE: If you are going to deploy this with Heroku, you'll need to run
> `heroku config:set JWT_KEY="xxxx"` with your specific key in place of `xxxx`
> at least once before you deploy. If you haven't setup deployment yet, make a
> note of this step to come back to once you've started your deployment process.

## Returning to the controller

Now that we have generated this JWT secret we can implement the `POST` method
for creating our user login session.

```csharp
[HttpPost]
public async Task<ActionResult> Login(LoginUser loginUser)
{
    var foundUser = await _context.Users.FirstOrDefaultAsync(user => user.Email == loginUser.Email);

    if (foundUser != null && foundUser.IsValidPassword(loginUser.Password))
    {
        // create a custom response
        var response = new
        {
            // This is the login token
            token = new TokenGenerator(JWT_KEY).TokenFor(foundUser),

            // The is the user details
            user = foundUser
        };

        return Ok(response);
    }
    else
    {
        // Make a custom error response
        var response = new
        {
            status = 400,
            errors = new List<string>() { $"User does not exist" }
        };

        // Return our error with the custom response
        return BadRequest(response);
    }
}
```

You'll notice the `POST` method doesn't take a `User` object, but a `loginUser`
of type `LoginUser`. We need to do this since we **do** need to read the
`Password` while the user is logging in. Thus we'll define this class inside the
`SessionsController` to store the `Email` and `Password` strings.

```csharp
public class LoginUser
{
    public string Email { get; set; }
    public string Password { get; set; }
}
```

The `POST` method attempts to find an existing user that has the same email
address as the received user.

Next, it uses the `IsValidPassword` method we wrote in the `User` class to
detect if the password matches.

If we found a user `foundUser != null` **AND** the password watches we will
generate a response that looks like this:

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJZCI6IjEiLCJGdWxsTmFtZSI6IkdhdmluIFN0YXJrIiwiRW1haWwiOiJnYXZpbkBnc3RhcmsuY29tIiwibmJmIjoxNTk0MjMyOTE5LCJleHAiOjE1OTQyNjg5MTksImlhdCI6MTU5NDIzMjkxOX0.k-xpH_Fu45BBUQWWTWHVxATAZk-X_Ae-_hXZFjF8LQE",
  "user": { "Id": "1", "FullName": "Gavin Stark", "Email": "gavin@suncoast.io" }
}
```

The `token` part of this object is created using
`new TokenGenerator(JWT_KEY).TokenFor(foundUser)`. This `TokenGenerator` class
is provided by SDG to generate JWT tokens for your users. If you are interested
in how the code works, it is documented within.

To use the `TokenGenerator` code we need to add a dependency to our project:

```shell
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

We also include the `user` object in the response. This is so the client has a
simple way to access this data.

This custom object is then returned as the payload of the successful API
response.

If either the `foundUser` is `null` or the password does not match, we return an
error message object which the form can process and display to the user.

## Give it a try!

To test if this works we can use both the `POST /api/Users` and
`POST /api/Sessions` endpoints from Insomnia. First, we can create a user, then
we can try the same `email` and `password` to the `Sessions` endpoint and see if
we get back a valid response. Try an invalid password or an email address that
doesn't correspond to an account to see the error messages.

Next up we'll connect the user interface to these controllers.

<GithubCommitViewer repo="gstark/TacoTuesday" commit="16cd52e97cbad559983947ea2f1116706d381ce8" />
