
# Recording upvotes and downvotes

To add the upvotes and downvotes we will add two new properties to our
`Restaurant` model: `UpvoteCount` and `DownvoteCount`.

These fields, however, are a little different than the others. While we do want
users of the API to be able to see these fields when creating, or even updating,
a restaurant's details we do not want the API to allow direct changing of these
fields.

We will create a `set;` accessor for these fields. However, we will mark them as
private so that external code cannot access them. This prevents us from writing
code like `restaurant.UpvoteCount++` and from the API code allowing us to modify
the `upvoteCount` via JSON. However, we will still see a `upvoteCount` field on
the API to get a restaurant or a list of restaurants.

We also define a default value of `0` for the upvote and downvote so that when a
new record is created we default these to a reasonable value.

Finally, we add two methods to allow us to increase the upvote and downvote
count.

It is these values that we will use to modify the counts.

```csharp
public int UpvoteCount { get; private set; } = 0;
public void IncreaseUpvoteCount()
{
    this.UpvoteCount++;
}


public int DownvoteCount { get; private set; } = 0;
public void IncreaseDownvoteCount()
{
    this.DownvoteCount++;
}
```

## Add a migration and run it

Since we have modified a column on the model we will run a migration to add
these columns to the database.

```shell
dotnet ef migrations add AddUpAndDownVoteCountsToRestaurants
```

And now we can run the migration:

```shell
dotnet ef database update
```

## Check the API Swagger documentation

If you check the `GET` and `POST` API documentation you will see that
`upvoteCount` and `downvoteCount` are both available to read, but neither appear
in the documentation for `POST.

This is exactly what we want. Users should not be able to **give** us a new
value for either, but use a specific API for _incrementing_ either.

# Representations of Resources

Before we move on to discuss how we are going to extend our API for upvotes and
downvotes, let's take a detour to discuss the idea of _resources_ and **REST**.

We've done a good job so far of providing a way for the front end to receive a
list of data from the backend via the `endpoint` of `GET /api/Restaurants`.

The API generated by our controller is following a particular style. You will
have noticed that all of the endpoints that deal with retrieving data use `GET`,
(e.g. `GET /api/Restaurants` and `GET /api/Restaurants/{id}`) while the endpoint
used to delete a restaurant uses `DELETE`

This introduces the idea of a `Resource` -- a `Resource` is like an `Entity`
from our `ERD` except that a `Resource` doesn't always directly correspond to a
database table.

A `resource` is any representation of data that we wish to address over the
network via an API. In this case we have two resources:

`The list of all restaurants`

and

`A specific restaurant`

When we ask for a resource we specify a few things:

- The resource itself
- The format we wish the data in
- The action we wish to perform on the resource

In our API the `format we wish the data in` will always be JSON. We'll come back
to this in a moment.

Let's take the case of a single restaurant. There are _three_ endpoints in our
API. `GET /api/Restaurants/{id}`, `PUT /api/Restaurants/{id}`, and
`DELETE /api/Restaurants/{id}`. In this case `/api/Restaurants/{id}` refer to
the resource itself: _the specific restaurant given by its identifier_ and the
verb (`GET`,`PUT`,`DELETE`) refers to the action we wish to take, _fetching_,
_updating_, and _removing_.

Thinking again about the idea of data formats and the endpoint
`GET /api/Restaurants/{id}` we said that this will return `JSON` data. What if,
for any given restaurant, we also store an image of this restaurant. We could
add another endpoint for the same **resource** but change the URL slightly such
as `GET /api/Restaurants/{id}.png` and we would know that we were requesting the
image of the restaurant, not the `JSON` data. Another way to handle this would
be to add a header that indicates the type of data we want. In this case, we
would specify the same URL of `GET /api/Restaurants/{id}` but include an
`Accept` header with a value such as `image/png` to indicate we want the image
version of this resource.

The _list of restaurants_ is also a **resource** that can be managed. For
instance, `GET /api/Restaurants` retrieves that resource, the list itself.
Whereas `POST /api/Restaurants` serves to **add** a restaurant to that list.
Here there is a single resource with different verbs to represent the action we
can take.

The idea of endpoints, URLs, representing resources along with actions and
formats of data is a powerful concept wrapped up in an approach called `REST`
and when we follow this approach we say that we are creating a `REST API` or
`RESTful API`.

The full application of the `REST` programming style is simultaneously subtle as
well as complex. It is captured in
[the Ph.D. thesis](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
of Roy Fielding. And while an academic paper it is well written and accessible.
It is well worth a read if you want to appreciate the simplicity of REST, along
with HTTP, but also build an understanding of the power of the architectural
idea.

For a simpler description of REST, I recommend an article titled
[How I Explained REST to My Wife](http://www.looah.com/source/view/2284)

## Adding an API for incrementing an upvote or a downvote

To think about how we are going to extend our API to include a way for a user to
upvote or downvote a restaurant we'll have to think a little bit abstractly.
We'll have to think about resources.

Another way to think about an upvote or a downvote is simply as a resource of a
`vote` which has two flavors, up and down. And making an upvote or downvote is
like `CREATING` a `RestaurantVote`.

As such we could think of the API for this as a `POST` on a `RestaurantVote`
resource, and thus we can have a `RestaurantVotesController` to manage these.
The only action in this controller will be a `POST` action and the method itself
won't deal with a `RestaurantVote` model or table since no such thing exists.

The fact that a model or table doesn't exist shouldn't restrict our thinking
about the system as resources, even if these resources are conceptual only.

Another benefit of having a `RestaurantsVotesController` is that at some point
we **may** want to record details about up and down votes. For instance, we may
want to keep a person for up or downvoting a restaurant multiple times. In this
case, we **will** have a database table we will use to tell if a user has
previously voted. It would also give us a history of votes we could do some data
analysis on.

We could also have added an endpoint such as `POST /api/Restaurants/{id}/upvote`
and `POST /api/Restaurants/{id}/downvote` but this feels like we are attaching
special features to a restaurant. When you step back and look at your domain as
a set of resources, even if some don't map directly to tables, you can start to
see the benefit of the `REST` style.

For now, we will use this as a chance to experiment with having a controller
that represents an abstract resource.

## Create a `RestaurantVotesController`

We won't use the scaffold here since we are creating this controller manually.

The only HTTP method in our code will be:

```csharp
// Up or down votes a specific restaurant
//
// Allow us to specify the restaurant id
// and a string to indicate if this is an up or downvote
//
// Examples:   /api/RestaurantVotes/42/upvote
// Examples:   /api/RestaurantVotes/100/downvote
[HttpPost("{id}/{upOrDown}")]
public async Task<IActionResult> PostRestaurantVote(int id, string upOrDown)
```

With this setup we must specify the restaurant id as well as a string indicating
which direction we are upvoting.

The body of the method will:

- Search for the specified restaurant
- Return a 404 Not Found if the ID doesn't exist
- If the `upOrDown` is upvote, call the method that increases the upvote
- If the `upOrDown` is downvote, call the method that increases the downvote
- Mark the restaurant as modified
- Save it
- Return a 204 NoContent to indicate success

```csharp
[HttpPost("{id}/{upOrDown}")]
public async Task<IActionResult> PostRestaurantVote(int id, string upOrDown)
{
    // Find the restaurant in the database using `FindAsync` to look it up by id
    var restaurant = await _context.Restaurants.FindAsync(id);

    // If we didn't find anything, we receive a `null` in return
    if (restaurant == null)
    {
        // Return a `404` response to the client indicating we could not find a restaurant with this id
        return NotFound();
    }

    switch (upOrDown)
    {
        case "upvote":
            restaurant.IncrementUpvoteCount();
            break;

        case "downvote":
            restaurant.IncrementDownvoteCount();
            break;

        default:
            return BadRequest();
    }

    // Tell the database to consider everything in restaurant to be _updated_ values. When
    // the save happens the database will _replace_ the values in the database with the ones from restaurant
    _context.Entry(restaurant).State = EntityState.Modified;

    // Try to save these changes.
    await _context.SaveChangesAsync();

    // return NoContent to indicate the update was done.
    return NoContent();
}
```

With this structure we:

- Hide the ability for a user to **directly** update the up and downvote count
  numbers
- Expose the current up and downvote values in the Restaurant `GET` APIs
- Add a specific API for `RestaurantVote` resources (upvotes and downvotes)

## Files Updated

- [Models/Restaurant.cs](https://raw.githubusercontent.com/gstark/TacoTuesday/76265c4cbb5fe4cbeb1af868fbe417224c9a9757/Models/Restaurant.cs)
- [Migrations/20200706021021_AddUpAndDownVoteCountsToRestaurants.cs](https://raw.githubusercontent.com/gstark/TacoTuesday/76265c4cbb5fe4cbeb1af868fbe417224c9a9757/Migrations/20200706021021_AddUpAndDownVoteCountsToRestaurants.cs)
- [Migrations/20200706021021_AddUpAndDownVoteCountsToRestaurants.Designer.cs](https://raw.githubusercontent.com/gstark/TacoTuesday/76265c4cbb5fe4cbeb1af868fbe417224c9a9757/Migrations/20200706021021_AddUpAndDownVoteCountsToRestaurants.Designer.cs)
- [Migrations/DatabaseContextModelSnapshot.cs](https://raw.githubusercontent.com/gstark/TacoTuesday/76265c4cbb5fe4cbeb1af868fbe417224c9a9757/Migrations/DatabaseContextModelSnapshot.cs)
- [Controllers/RestaurantVotesController.cs](https://raw.githubusercontent.com/gstark/TacoTuesday/76265c4cbb5fe4cbeb1af868fbe417224c9a9757/Controllers/RestaurantVotesController.cs)

---

# Using the up and downvote API from the user interface

First, let's update the user interface to display the current up and downvote
numbers

```text
<span className="mr-2" role="img" aria-label="upvote">
  👍🏻
</span>
{restaurant.upvoteCount}
```

and

```text
<span className="mr-2" role="img" aria-label="downvote">
  👎🏻
</span>{restaurant.downvoteCount}
```

Then we will add click handlers for the buttons themselves

```jsx
<button className="btn btn-success btn-sm" onClick={handleUpvote}>
```

and

```jsx
<button className="btn btn-success btn-sm" onClick={handleDownvote}>
```

and define the `handle` methods:

```javascript
const handleUpvote = () => {
  const url = `/api/RestaurantVotes/${restaurant.id}/upvote`

  fetch(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  }).then(() => {
    console.log('Need to reload the restaurants')
  })
}

const handleDownvote = () => {
  const url = `/api/RestaurantVotes/${restaurant.id}/downvote`

  fetch(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  }).then(() => {
    console.log('Need to reload the restaurants')
  })
}
```

However, both of these handlers will want to reload the restaurants. We have two
choices. The first is to pass the component a method that will reload the
restaurants. The other is to move the up and downvote to the parent class so
that the state we need to reload is available. Let's take that path.

We'll remove the `handleDownvote` method and **move** and **rename** the
`handleUpvote` method to the parent component `Restaurants`. We will also have
it take two arguments, the first being the id of the restaurant, and the other
which style vote we are processing.

```javascript
const handleVote = (id, type) => {
  const url = `/api/RestaurantVotes/${id}/${type}`

  fetch(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  }).then(() => {
    console.log('Need to reload the restaurants')
  })
}
```

Next, we will change the code to extract the method that reloads the restaurants
so we can call it from this method **and** the `useEfffect`

```javascript
useEffect(() => {
  reloadRestaurants()
}, [props.activeFilter])

const reloadRestaurants = () => {
  const url =
    props.activeFilter.length === 0
      ? `/api/Restaurants`
      : `/api/Restaurants?filter=${props.activeFilter}`

  fetch(url)
    .then(response => response.json())
    .then(apiData => {
      setRestaurants(apiData)
    })
}

const handleVote = (id, type) => {
  const url = `/api/RestaurantVotes/${id}/${type}``

  fetch(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  }).then(() => {
    reloadRestaurants()
  })
}
```

Now we can pass the `handleVote` method to the `SingleRestaurantFromList`
component when it is used.

```jsx
<SingleRestaurantFromList
  key={restaurant.id}
  restaurant={restaurant}
  handleVote={handleVote}
/>
```

And we can change the buttons to use it appropriately

```jsx
<button
  className="btn btn-success btn-sm"
  onClick={() => props.handleVote(restaurant.id, 'upvote')}
>

...

<button
  className="btn btn-danger btn-sm"
  onClick={() => props.handleVote(restaurant.id, 'upvote')}
>
```

If you try this code you may notice a problem. The button is inside the `<Link>`
and we are **navigating** when we mean only for the button click to happen.

Again we have to augment the `button` with code to stop a normal behavior.

We will change the `button` code slightly

```jsx
<button
  className="btn btn-success btn-sm"
  onClick={event => {
    event.preventDefault()
    props.handleVote(restaurant.id, 'upvote')
  }}
>

...

<button
  className="btn btn-danger btn-sm"
  onClick={event => {
    event.preventDefault()
    props.handleVote(restaurant.id, 'downvote')
  }}
>
```

This is great. We can now up and down vote restaurants. However, you may notice
that the _order_ of the restaurants is not consistent. This is because the API
does not specify a sorting order and we get the records back in whatever order
the database wants. We do not want to leave this up to the database. Let's add a
sort order by the restaurant name.

Update the code in `GetRestaurants` to have this instead:

```csharp
if (filter == null)
{
    return await _context.Restaurants.OrderBy(restaurant => restaurant.Name).ToListAsync();
}
else
{
    return await _context.Restaurants.OrderBy(restaurant => restaurant.Name).Where(restaurant => restaurant.Name.Contains(filter)).ToListAsync();
}
```

And now when we click an up/downvote we do not get a reordering of the
restaurants and the visual effect is that we are just incrementing the counter
as we should.

## Files Updated

- [ClientApp/src/pages/Restaurants.jsx](https://raw.githubusercontent.com/gstark/TacoTuesday/066e831b0dfe119282dae8ea9a74c9001cadfdc4/ClientApp/src/pages/Restaurants.jsx)
- [Controllers/RestaurantsController.cs](https://raw.githubusercontent.com/gstark/TacoTuesday/master/Controllers/RestaurantsController.cs)
